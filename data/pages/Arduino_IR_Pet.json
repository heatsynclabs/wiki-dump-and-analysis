{
  "title": "Arduino IR Pet",
  "ns": 0,
  "id": 230,
  "slug": "Arduino_IR_Pet",
  "latest_revision": {
    "id": 1734,
    "timestamp": "2011-01-19T04:48:50Z",
    "contributor": {
      "username": "Uberschnitzel",
      "ip": null,
      "id": 9
    },
    "comment": "/* Assembly */",
    "text": "This is code used in teaching an Arduino workshop. It combines a 16x2 character LCD, an IR LED, an IR photodetector, and a piezo speaker to form an electronic \"pet\" similar to a Tamogachi.\n\nFor assistance with this code, please post in the HeatSync Google Group in this thread: [http://groups.google.com/group/heatsynclabs/browse_thread/thread/72528934bf0a1662 HSL Thread: Arduino IR Pet (workshop code)]\n\n==Assembly==\n(Assembly instructions/photos still being posted here, thanks for your patience.)\n\nPhoto:\n[[File:Arduino_IR_Pet_Photo.JPG|500px]]\n\nSorry for the blurriness, but this should give you an idea of how to construct the IR Pet (along with the comments at the top of the code below.)\n\nThe linked schematic explains how to set up the IR sensors on both sides:<br>\nhttp://www.flickr.com/photos/jerrya-net/4111242116/\n\n==Libraries==\n\nDownload and extract this ZIP into your arduino app's libraries folder-- resulting file structure should look like arduino\\libraries\\tone\\tone.h\n\n[[File:Tone.zip]]\n\n== Code ==\n\n<pre>\n\n/*\n  HeatSync Labs IR Pet\n  \n Demonstrates the use of a 16x2 LCD display, IR emitters and sensors, Piezo \n \n  The circuit:\n * LCD PWR- pin to GND\n * LCD PWR+ pin to +5V\n * LCD RS pin to digital pin 7\n * LCD Enable pin to digital pin 8\n * LCD D4 pin to digital pin 9\n * LCD D5 pin to digital pin 10\n * LCD D6 pin to digital pin 11\n * LCD D7 pin to digital pin 12\n * Potentiometer:\n *  ends to +5V and ground\n *  center (\"wiper\") to LCD VO pin (LCD pin 3)\n * Photodetector:\n *  connect to digital pin 3 with a resistor in between, and GND \n * LED: \n *  connect to digital pin 2 with a resistor in between, and GND\n * Piezo Speaker:\n *  connect to digital pin 5 and GND\n \n  Operation: \n * Once powered on and this code uploaded, the LCD should show a HeatSync Labs splash screen followed by health and happiness gauges.\n * If you can't see anything on the LCD, try adjusting the potentiometer. If you see garbled stuff, press the reset button on the arduino or double-check your wiring.\n * To increase the pet's happiness, \"feed\" its IR photodetector with infrared light (possibly from its own infrared LED, or a remote control, or another pet's LED.)\n * To increase the pet's health, \"clean up\" after it by making a loud noise into the piezo (try blowing on the piezo, it can act like a really weak microphone!)\n * If you get continuous heart or smiley animations and noises, some of your sensors may be stuck on (i.e. the IR photodetector) or they might be wired incorrectly (my photodetector produces a 0 when active and 1 when inactive, for example.)\n \n */\n\n// include the LCD library code:\n#include <LiquidCrystal.h>\n// include the RTTTL Tone (music) library:\n#include <Tone.h>\n\n/*\n * This section for music settings\n */\nTone tone1;\n\n#define OCTAVE_OFFSET 0\n\nint notes[] = { 0,\nNOTE_C4, NOTE_CS4, NOTE_D4, NOTE_DS4, NOTE_E4, NOTE_F4, NOTE_FS4, NOTE_G4, NOTE_GS4, NOTE_A4, NOTE_AS4, NOTE_B4,\nNOTE_C5, NOTE_CS5, NOTE_D5, NOTE_DS5, NOTE_E5, NOTE_F5, NOTE_FS5, NOTE_G5, NOTE_GS5, NOTE_A5, NOTE_AS5, NOTE_B5,\nNOTE_C6, NOTE_CS6, NOTE_D6, NOTE_DS6, NOTE_E6, NOTE_F6, NOTE_FS6, NOTE_G6, NOTE_GS6, NOTE_A6, NOTE_AS6, NOTE_B6,\nNOTE_C7, NOTE_CS7, NOTE_D7, NOTE_DS7, NOTE_E7, NOTE_F7, NOTE_FS7, NOTE_G7, NOTE_GS7, NOTE_A7, NOTE_AS7, NOTE_B7\n};\n\n  char *songA = \"MissionImp:d=16,o=6,b=95:32d,32d#,32d,32d#,32d,32d#,32d,32d#,32d,32d,32d#,32e,32f,32f#,32g,g,8p\";\n  char *songB = \"shorter_r2d2:d=4,o=5,b=450:16c#7,16g#7,16f6,16a#7,16e7,16g#8,16e8,16g#6,16g7,16c#7,16g7,16f#8,16c#7,16f#6,16f8,16g#7,16g6,16a8,16c#8,16g6,16f#8,16g7,16f8,16a#6,16f#8,16d8,16g7,16g8,16c8,16g#6,16a8\";\n\n#define isdigit(n) (n >= '0' && n <= '9')\n\n/*\n * This section for custom characters on the LCD\n */\n \n// blank \nbyte blank[8] = {\tB00000,\tB00000,\tB00000,\tB00000,\tB00000,\tB00000,\tB00000,\tB00000};\n// smiley\nbyte smiley[8] = {\tB00000,\tB01010,\tB01010,\tB00000,\tB10001,\tB10001,\tB01110,\tB00000};\n// heart\nbyte heart[8] = {\tB00000,\tB01010,\tB10101,\tB10001,\tB10001,\tB01010,\tB00100,\tB00000};\n// chip\nbyte chip[8] = {\tB01110,\tB11111,\tB01110,\tB11111,\tB01110,\tB11111,\tB01110,\tB11111};\n// heatsync logo\nbyte hsl_toplft[8] = {\tB00000,\tB00000,\tB00000,\tB00011,\tB00100,\tB00100,\tB01001,\tB01011};\nbyte hsl_toprt[8] = {\tB00000,\tB00000,\tB01010,\tB11010,\tB00101,\tB00111,\tB00010,\tB00011};\nbyte hsl_btmrt[8] = {\tB11010,\tB10110,\tB01111,\tB11001,\tB01100,\tB01110,\tB00000,\tB00000};\nbyte hsl_btmlft[8] = {\tB01000,\tB00100,\tB01100,\tB01011,\tB00010,\tB00110,\tB00000,\tB00000};\n\n/*\n * This section for public variables used for the program runtime\n */\n\nLiquidCrystal lcd(7,8,9,10,11,12); // initialize the library with the numbers of the interface pins\nint sensorValue = 0;  // variable to store the value coming from the sensor\nint ledPin = 2;    // select the output pin for the IR LED\nint sensorPin = 3;    // select the input pin for the IR sensor\nint speakerPin = 5;   // select the output pin for the speaker\nint speakerValue = 0;  // variable to store whether the button is currently pushed\nint buttonPin = 4;    // select the input pin for the button\nint health = 50;      // starting \"health\"\nint happy = 50;       // starting \"happiness\"\nint loopCounter = 0;  // just a counter to space out events within the loop() below\n\n\nvoid setup() {\n  // set up the LCD's number of columns and rows: \n  lcd.begin(16, 2);\n  // set up the speaker's pin number\n  tone1.begin(speakerPin);\n  // set up serial communication (back to the PC via USB for debugging)\n  Serial.begin(9600);\n  // declare the sensorPin as an INPUT:\n  pinMode(sensorPin, INPUT);  \n  // write the sensorPin high\n  digitalWrite(sensorPin, HIGH); \n  // declare the ledPin as an OUTPUT:\n  pinMode(ledPin, OUTPUT); \n\n  lcd.createChar(0, blank);\n  lcd.createChar(1, smiley);\n  lcd.createChar(2, heart);\n  lcd.createChar(3, chip);\n  lcd.createChar(4, hsl_toplft);\n  lcd.createChar(5, hsl_toprt);\n  lcd.createChar(6, hsl_btmrt);\n  lcd.createChar(7, hsl_btmlft);\n  lcd.begin(16, 2);\n\n  showBootScreen();\n  delay(2000);\n  lcd.clear();\n}\n\n\nvoid loop() {\n  loopCounter++;\n  if(loopCounter > 400)\n  {\n    adjustHealth(-1);\n    loopCounter = 0;\n    makeDirty();\n  }\n  \n  if(loopCounter % 100 == 0)\n  {\n    adjustHappy(-1); \n  }\n  \n  \n  showHealth();\n  showHappy();\n  \n  digitalWrite(ledPin, HIGH); \n  \n  // read the value from the sensor:\n  sensorValue = digitalRead(sensorPin); \n  if(sensorValue == 0)  // for some reason IR transistors are 0 when light and 1 when dark?\n  {\n    Serial.println(\"Sensor\");\n    feedChips();\n  }  \n \n  // declare the speakerPin as an INPUT:\n  pinMode(speakerPin, INPUT);  \n  delay(100);    \n  speakerValue = digitalRead(speakerPin);\n  if(speakerValue == 1)\n  {\n    Serial.println(\"Speaker\");\n    cleanUp();\n  }\n  delay(100);    \n  \n}\n\n\nvoid makeDirty() {\n  lcd.setCursor(random(4, 11) ,random(0, 2));\n  lcd.print(\".\");\n  delay(100);\n}\n\nvoid cleanUp() {\n  play_rtttl(songA);\n  \n  adjustHealth(6);\n  writeAt(2,0,0);\n  delay(100);\n  writeAt(0,0,0);\n  writeAt(2,1,1);\n  delay(100);\n  writeAt(0,1,1);\n  writeAt(2,2,0);\n  delay(100);\n  writeAt(0,2,0);\n  writeAt(2,3,1);\n  delay(100);\n  writeAt(0,3,1);\n  writeAt(0,4,0);\n  writeAt(0,5,0);\n  writeAt(0,6,0);\n  writeAt(0,7,0);\n  writeAt(0,8,0);\n  writeAt(0,9,0);\n  writeAt(0,10,0);\n  writeAt(0,11,0);\n  writeAt(0,12,0);\n  writeAt(0,4,1);\n  writeAt(0,5,1);\n  writeAt(0,6,1);\n  writeAt(0,7,1);\n  writeAt(0,8,1);\n  writeAt(0,9,1);\n  writeAt(0,10,1);\n  writeAt(0,11,1);\n  writeAt(0,12,1);\n}\n\nvoid feedChips() {\n  \n  play_rtttl(songB);\n\n  adjustHappy(8);\n  writeAt(3,0,0);\n  delay(100);\n  writeAt(0,0,0);\n  writeAt(3,1,1);\n  delay(100);\n  writeAt(0,1,1);\n  writeAt(3,2,0);\n  delay(100);\n  writeAt(0,2,0);\n  writeAt(3,3,1);\n  delay(100);\n  writeAt(0,3,1);\n}\n\nvoid writeAt(int character, int x, int y) {\n  lcd.setCursor(x, y);\n  lcd.write(character); \n}\n\n\nvoid adjustHealth(int diff){\n  if(health > 0)\n  {\n    health = health + diff;\n  }\n  if(health > 99)\n  {\n    health = 99; \n  }\n}\n\nvoid adjustHappy(int diff){\n  if(happy > 1 || diff > 0)\n  {\n    happy = happy + diff;\n  }\n  if(happy > 99)\n  {\n    happy = 99; \n  }\n}\n\nvoid showHappy() {\n  lcd.setCursor(13, 1);\n  lcd.write(1);\n  lcd.print(happy);\n  lcd.write(0);\n}\n\nvoid showHealth() {\n  lcd.setCursor(13, 0);\n  lcd.write(2);\n  lcd.print(health);\n  lcd.write(0);\n}\n\nvoid showBootScreen(){\n  lcd.setCursor(0, 0);\n  lcd.write(4);\n  lcd.write(5);\n  lcd.setCursor(0, 1);\n  lcd.write(7);\n  lcd.write(6);\n\n  lcd.setCursor(3, 0);\n  lcd.print(\"HeatSync Labs\");\n  \n  lcd.setCursor(3, 1);\n  lcd.print(\"BootROM v1337\"); \n}\n\n\n\n\nvoid play_rtttl(char *p)\n{\n  // Absolutely no error checking in here\n\n  byte default_dur = 4;\n  byte default_oct = 6;\n  int bpm = 63;\n  int num;\n  long wholenote;\n  long duration;\n  byte note;\n  byte scale;\n\n  // format: d=N,o=N,b=NNN:\n  // find the start (skip name, etc)\n\n  while(*p != ':') p++;    // ignore name\n  p++;                     // skip ':'\n\n  // get default duration\n  if(*p == 'd')\n  {\n    p++; p++;              // skip \"d=\"\n    num = 0;\n    while(isdigit(*p))\n    {\n      num = (num * 10) + (*p++ - '0');\n    }\n    if(num > 0) default_dur = num;\n    p++;                   // skip comma\n  }\n\n  //Serial.print(\"ddur: \"); Serial.println(default_dur, 10);\n\n  // get default octave\n  if(*p == 'o')\n  {\n    p++; p++;              // skip \"o=\"\n    num = *p++ - '0';\n    if(num >= 3 && num <=7) default_oct = num;\n    p++;                   // skip comma\n  }\n\n  //Serial.print(\"doct: \"); Serial.println(default_oct, 10);\n\n  // get BPM\n  if(*p == 'b')\n  {\n    p++; p++;              // skip \"b=\"\n    num = 0;\n    while(isdigit(*p))\n    {\n      num = (num * 10) + (*p++ - '0');\n    }\n    bpm = num;\n    p++;                   // skip colon\n  }\n\n  //Serial.print(\"bpm: \"); Serial.println(bpm, 10);\n\n  // BPM usually expresses the number of quarter notes per minute\n  wholenote = (60 * 1000L / bpm) * 4;  // this is the time for whole note (in milliseconds)\n\n  //Serial.print(\"wn: \"); Serial.println(wholenote, 10);\n\n\n  // now begin note loop\n  while(*p)\n  {\n    // first, get note duration, if available\n    num = 0;\n    while(isdigit(*p))\n    {\n      num = (num * 10) + (*p++ - '0');\n    }\n    \n    if(num) duration = wholenote / num;\n    else duration = wholenote / default_dur;  // we will need to check if we are a dotted note after\n\n    // now get the note\n    note = 0;\n\n    switch(*p)\n    {\n      case 'c':\n        note = 1;\n        break;\n      case 'd':\n        note = 3;\n        break;\n      case 'e':\n        note = 5;\n        break;\n      case 'f':\n        note = 6;\n        break;\n      case 'g':\n        note = 8;\n        break;\n      case 'a':\n        note = 10;\n        break;\n      case 'b':\n        note = 12;\n        break;\n      case 'p':\n      default:\n        note = 0;\n    }\n    p++;\n\n    // now, get optional '#' sharp\n    if(*p == '#')\n    {\n      note++;\n      p++;\n    }\n\n    // now, get optional '.' dotted note\n    if(*p == '.')\n    {\n      duration += duration/2;\n      p++;\n    }\n  \n    // now, get scale\n    if(isdigit(*p))\n    {\n      scale = *p - '0';\n      p++;\n    }\n    else\n    {\n      scale = default_oct;\n    }\n\n    scale += OCTAVE_OFFSET;\n\n    if(*p == ',')\n      p++;       // skip comma for next note (or we may be at the end)\n\n    // now play the note\n\n    if(note)\n    {\n     // Serial.print(\"Playing: \");\n      //Serial.print(scale, 10); Serial.print(' ');\n      //Serial.print(note, 10); Serial.print(\" (\");\n      //Serial.print(notes[(scale - 4) * 12 + note], 10);\n      //Serial.print(\") \");\n      //Serial.println(duration, 10);\n      tone1.play(notes[(scale - 4) * 12 + note]);\n      delay(duration);\n      tone1.stop();\n    }\n    else\n    {\n      //Serial.print(\"Pausing: \");\n      //Serial.println(duration, 10);\n      delay(duration);\n    }\n  }\n}\n</pre>\n\n==Parts List==\n\nNPN Transistor:<br>\nhttp://www.mouser.com/ProductDetail/Fairchild-Semiconductor/KSC3503DSTU/?qs=sGAEpiMZZMtn7beagP2hIRaqh2YBECe1Yqoz3NTyz48%3d\n\nIR Emitter:<br>\nhttp://mouser.com/search/ProductDetail.aspx?qs=8T8Vkz9kCnmXLF3JXFC7QQ==\n\nIR Receiver:<br>\nhttp://mouser.com/search/ProductDetail.aspx?qs=WxFF5lh7QM1L5Vm%2btOeRTw==\n\nStandard LCD 16x2 + Extras(White on Blue):<br>\nhttp://www.adafruit.com/index.php?main_page=product_info&cPath=37&products_id=181\n\nPiezo Buzzer - PS1240:<br> \nhttp://www.adafruit.com/index.php?main_page=product_info&cPath=35&products_id=160",
    "bytes": 12237
  },
  "revision_count": 6,
  "first_revision_timestamp": "2010-11-19T19:57:25Z",
  "is_redirect": false
}