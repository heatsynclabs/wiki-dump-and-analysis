{
  "title": "Pebble",
  "ns": 0,
  "id": 304,
  "slug": "Pebble",
  "latest_revision": {
    "id": 2063,
    "timestamp": "2011-03-02T23:11:25Z",
    "contributor": {
      "username": "Jac goudsmit",
      "ip": null,
      "id": 47
    },
    "comment": "Forgot the R in the buttons formula",
    "text": "=Introduction=\nThe Pebble is an Arduino shield that provides you with some interesting, common I/O devices, such as a temperature sensor, LDR, potentiometer, pushbuttons and an LCD display, all nicely integrated onto a PCB, to easily let you get started experimenting with Arduino programs.  \n\n* The hardware files are located at https://github.com/lukeweston/Pebble/ \n* The Software is kept at https://github.com/geekscape/Aiko\n* The OneWire library is here: [[File:OneWire.zip]]\n\nThe Pebble has a multitude of cool electronic components for you to play with.  Our implementation of these boards include a 'standard' set of features and optional addons.\n\n==HeatSync Workshop/Kit Materials==\n\n===Photo of assembled Pebble Arduino shield (HeatSync batch)===\n\n[[File:Pebble-assembled-top.jpg|200px]]\n\n===Bill of Materials===\n\n[[File:Pebble-bom.pdf|200px]]\n\n===Schematic===\n\n[[File:Pebble-sch.png|200px]]\n\n===Resistor color codes (ready to print)===\n\n[[File:Resistor-codes-6up.gif|200px]]\n\n\n==Standard Features==\n===8 bit shift register===\n====Description====\nShift registers take in serial data (one number at a time, 1, 0, 1, 0, 1, 1, 1, 0) and express that data in parallel across 8 pins (10101110).  It basically turns one data pin into 8!  For some operations you could think of it as a multiplexer.  For this example it is important to read up on the [http://www.arduino.cc/en/Tutorial/ShiftOut shiftOut] Arduino function as that does almost all of the hard work for you!  This example again repurposes an the [Hello World http://arduino.cc/en/Tutorial/ShftOut11] example from that page and substitutes our proper pins; CLOCK = 4, \nDATA 3, STROBE = 2.\n\n====Code====\n<pre>\n int CLOCK = 4;\n int DATA = 3;\n int STROBE = 2;\n\nvoid setup() {\n  //set pins to output so you can control the shift register\n  pinMode(STROBE, OUTPUT);\n  pinMode(CLOCK, OUTPUT);\n  pinMode(DATA, OUTPUT);\n}\n\nvoid loop() {\n  // count from 0 to 255 and display the number \n  // on the LEDs\n  for (int numberToDisplay = 0; numberToDisplay < 256; numberToDisplay++) {\n    // take the latchPin low so \n    // the LEDs don't change while you're sending in bits:\n    digitalWrite(STROBE, LOW);\n    // shift out the bits:\n    shiftOut(DATA, CLOCK, MSBFIRST, numberToDisplay);  \n\n    //take the latch pin high so the LEDs will light up:\n    digitalWrite(STROBE, HIGH);\n    // pause before next value:\n    delay(500);\n  }\n}\n</pre>\n\n===Temperature sensor===\n\n====Description====\nThe temperature sensor is the [[http://www.maxim-ic.com/datasheet/index.mvp/id/2812 DS18B20]] IC and utilizes a library called [[http://www.arduino.cc/playground/Learning/OneWire OneWire]]. The value should generally read 25 C indoors. If you squeeze the sensor with your finger that value should rise fairly quickly to 30 C.\n\n====Code====\nMy example crudely combines the Aiko LCD example and the Aiko temperature example to display the temperature to the screen.  Note this example requires the OneWire library to be installed to your libraries directory of Arduino, in addition to the Aiko libraries.\n\n<pre>\n#include <AikoEvents.h>\n#include <AikoSExpression.h>\n\nusing namespace Aiko;\n\n#define PIN_LCD_STROBE      2 // CD4094 8-bit shift/latch\n#define PIN_LCD_DATA        3 // CD4094 8-bit shift/latch\n#define PIN_LCD_CLOCK       4 // CD4094 8-bit shift/latch\n#define PIN_ONE_WIRE 5\n\n\nvoid setup() {\n  Events.addHandler(temperatureSensorHandler, 1000);\n  Events.addHandler(lcdHandler,   1000);\n}\n\nvoid loop() {\n  Events.loop();\n}\n\n#include <OneWire.h>\n\nOneWire oneWire(PIN_ONE_WIRE);  // Maxim DS18B20 temperature sensor\n\nbyte oneWireInitialized = false;\n\n#define ONE_WIRE_COMMAND_READ_SCRATCHPAD  0xBE\n#define ONE_WIRE_COMMAND_START_CONVERSION 0x44\n#define ONE_WIRE_COMMAND_MATCH_ROM        0x55\n#define ONE_WIRE_COMMAND_SKIP_ROM         0xCC\n\n#define ONE_WIRE_DEVICE_18B20  0x28\n#define ONE_WIRE_DEVICE_18S20  0x10\n\nint temperature_whole = 0;\nint temperature_fraction = 0;\n\nvoid temperatureSensorHandler(void) {  // total time: 33 milliseconds\n  byte address[8];\n  byte data[12];\n  byte index;\n\n  if (! oneWire.search(address)) {  // time: 14 milliseconds\n//  Serial.println(\"(error 'No more one-wire devices')\");\n    oneWire.reset_search();         // time: <1 millisecond\n    return;\n  }\n\n  if (OneWire::crc8(address, 7) != address[7]) {\n//  sendMessage(\"(error 'Address CRC is not valid')\");\n    return;\n  }\n\n  if (address[0] != ONE_WIRE_DEVICE_18B20) {\n//  sendMessage(\"(error 'Device is not a DS18B20')\");\n    return;\n  }\n\n  if (oneWireInitialized) {\n    byte present = oneWire.reset();                   // time: 1 millisecond\n    oneWire.select(address);                          // time: 5 milliseconds\n    oneWire.write(ONE_WIRE_COMMAND_READ_SCRATCHPAD);  // time: 1 millisecond\n\n    for (index = 0; index < 9; index++) {             // time: 5 milliseconds\n      data[index] = oneWire.read();\n    }\n\n    if (OneWire::crc8(data, 8) != data[8]) {\n//    sendMessage(\"(error 'Data CRC is not valid')\");\n      return;\n    }\n\n    int temperature = (data[1] << 8) + data[0];\n    int signBit     = temperature & 0x8000;\n    if (signBit) temperature = (temperature ^ 0xffff) + 1;  // 2's complement\n\n    int tc_100 = (6 * temperature) + temperature / 4;  // multiply by 100 * 0.0625\n\n    temperature_whole    = tc_100 / 100;\n    temperature_fraction = tc_100 % 100;\n\n  }\n\n  // Start temperature conversion with parasitic power\n  oneWire.reset();                                      // time: 1 millisecond\n  oneWire.select(address);                              // time: 5 milliseconds\n  oneWire.write(ONE_WIRE_COMMAND_START_CONVERSION, 1);  // time: 1 millisecond\n\n  // Must wait at least 750 milliseconds for temperature conversion to complete\n  oneWireInitialized = true;\n}\n\n/* -------------------------------------------------------------------------- */\n/* LCD KS0066 4-bit data interface, 3 Arduino pins and MC14094 8-bit register\n * http://www.datasheetsite.com/datasheet/KS0066\n *\n * MC14094 input:  Arduino digital pin 2=Clock, pin 4=Data, pin 7=Strobe\n * MC14094 output: Q8=DB4, Q7=DB5, Q6=DB6, Q5=DB7, Q4=E, Q3=RW, Q2=RS, Q1=None\n * http://www.ee.mut.ac.th/datasheet/MC14094.pdf\n *\n *   +--------------------------------------------+\n *   |    Arduino (ATMega 168 or 328)             |\n *   |    D02           D03           D04         |\n *   +----+-------------+-------------+-----------+\n *        |4            |5            |6\n *        |1            |2            |3\n *   +----+-------------+-------------+-----------+\n *   |    Strobe        Data          Clock       |\n *   |    MC14094 8-bit shift/latch register      |\n *   |    Q8   Q7   Q6   Q5   Q4   Q3   Q2   Q1   |\n *   +----+----+----+----+----+----+----+----+----+\n *        |11  |12  |13  |14  |7   |6   |5   |4\n *        |11  |12  |13  |14  |6   |5   |4 \n *   +----+----+----+----+----+----+----+---------+\n *   |    DB4  DB5  DB6  DB7  E    RW   RS        |\n *   |               LCD KS0066                   |\n *   +--------------------------------------------+\n */\n\nbyte lcdInitialized = false;\n\n// LCD pin bit-patterns, output from MC14094 -> LCD KS0066 input\n#define LCD_ENABLE_HIGH 0x10  // MC14094 Q4 -> LCD E\n#define LCD_ENABLE_LOW  0xEF  //   Enable (high) / Disable (low)\n#define LCD_RW_HIGH     0x20  // MC14094 Q3 -> LCD RW\n#define LCD_RW_LOW      0xDF  //   Read (high) / Write (low)\n#define LCD_RS_HIGH     0x40  // MC14094 Q2 -> LCD RS\n#define LCD_RS_LOW      0xBF  //   Data (high) / Instruction (low) Select\n\n// LCD Commands\n#define LCD_COMMAND_CLEAR             0x01  // Clear display\n#define LCD_COMMAND_HOME              0x02  // Set DD RAM address counter to (0, 0)\n#define LCD_COMMAND_ENTRY_SET         0x06  // Entry mode set\n#define LCD_COMMAND_DISPLAY_SET       0x0C  // Display on/off control\n#define LCD_COMMAND_FUNCTION_SET      0x28  // Function set\n#define LCD_COMMAND_SET_DDRAM_ADDRESS 0x80  // Set DD RAM address counter (row, column)\n\n#define LCD_SECOND_ROW 0x40  // Second row literal\n\nbyte lcdSetup[] = {         // LCD command, delay time in milliseconds\n  LCD_COMMAND_HOME,         50,  // wait for LCD controller to be initialized\n  LCD_COMMAND_HOME,         50,  // ditto\n  LCD_COMMAND_FUNCTION_SET,  1,  // 4-bit interface, 2 display lines, 5x8 font\n  LCD_COMMAND_DISPLAY_SET,   1,  // turn display on, cursor off, blinking off\n  LCD_COMMAND_CLEAR,         2,  // clear display\n  LCD_COMMAND_ENTRY_SET,     1   // increment mode, display shift off\n};\n\nvoid lcdInitialize(void) {\n  pinMode(PIN_LCD_CLOCK,  OUTPUT);\n  pinMode(PIN_LCD_DATA,   OUTPUT);\n  pinMode(PIN_LCD_STROBE, OUTPUT);\n\n  byte length = sizeof(lcdSetup) / sizeof(*lcdSetup);\n  byte index = 0;\n\n  while (index < length) {\n    lcdWrite(lcdSetup[index ++], false);\n    delay(lcdSetup[index ++]);\n  }\n\n  lcdInitialized = true;\n}\n\nvoid lcdWrite(\n  byte value,\n  byte dataFlag) {\n\n  digitalWrite(PIN_LCD_STROBE, LOW);\n\n  byte output = value >> 4;                                    // Most Significant Nibble\n  if (dataFlag) output = (output | LCD_RS_HIGH) & LCD_RW_LOW;  // Command or Data ?\n\n  for (byte loop1 = 0; loop1 < 2; loop1 ++) {  // First MSN, then LSN\n    for (byte loop2 = 0; loop2 < 3; loop2 ++) {  // LCD ENABLE LOW -> HIGH -> LOW\n      output = (loop2 == 1) ? (output | LCD_ENABLE_HIGH) : (output & LCD_ENABLE_LOW);\n\n      shiftOut(PIN_LCD_DATA, PIN_LCD_CLOCK, LSBFIRST, output);\n      digitalWrite(PIN_LCD_STROBE, HIGH);\n      delayMicroseconds(10);\n      digitalWrite(PIN_LCD_STROBE,LOW);\n    }\ndelay(1);\n    output = value & 0x0F;                                       // Least Significant Nibble\n    if (dataFlag) output = (output | LCD_RS_HIGH) & LCD_RW_LOW;  // Command or Data ?\n  }\n}\n\nvoid lcdClear(void) {\n  lcdWrite(LCD_COMMAND_CLEAR, false);\n  delay(2);\n}\n\nvoid lcdPosition(\n  byte row,        // Must be either 0 (first row) or 1 (second row)\n  byte column) {   // Must be between 0 and 15\n\n  if (row == 1) row = LCD_SECOND_ROW;\n  lcdWrite(LCD_COMMAND_SET_DDRAM_ADDRESS | row | column, false);\n  delayMicroseconds(40);\n}\n\nvoid lcdWriteString(\n  char message[]) {\n\n  while (*message) lcdWrite((*message ++), true);\n}\n\n// checks out how many digits there are in a number\n\nint estimateDigits(int nr) {\n  int dec = 10;\n  int temp = 1;\n  int div = nr/dec;\n  while (div > 0) {\n    dec *= 10;\n    div = nr/dec;\n    temp++;\n  }\n  return temp;\n}\n\n// Raise number to power\n\nint pow(int base, int expo) {\n  int temp = 1;\n  for (int c = 1; c <= expo; c++) {\n    temp *= base;\n  }\n  return temp;\n}\n\n// this function help us to write numbers\n// with more than one digit\n\nvoid lcdWriteNumber(int nr, int digits) {\n  for (int i = digits-1; i >= 0; i--) {\n    int dec = pow(10,i);\n    int div = nr/dec;\n    lcdWrite(div+48, true);\n    if (div > 0) {\n      nr -= div*dec;\n    }\n  }\n}\n\nvoid lcdWriteNumber(int nr) {\n  int value = nr;\n\n  if (value < 0) {\n    lcdWrite('-', true);\n    value = - nr;\n  }\n\n  int digits = estimateDigits(value);\n  lcdWriteNumber(value, digits);\n}\n\nvoid lcdHandler(void) {\n  if (lcdInitialized == false) {\n    lcdInitialize();\n    lcdClear();\n  }\n\n  lcdPosition(0, 8);\n  lcdWriteNumber((int) temperature_whole);\n  \n\n}\n</pre>\n\n===Light sensor===\n  \n====Description====\nThe light sensor detects light on an analog pin and is located on A0.\n\n====Code====\nThe following code is simply the Aiko LCD code crudely combined with the Aiko Light sensor code to display the light values on the screen.  You should expect a value of ~900 for fluorescent lights indoor, and if you press your finger over the top of the sensor that value should fall to ~300.\n\n<pre>\n#include <AikoEvents.h>\n#include <AikoSExpression.h>\n\nusing namespace Aiko;\n\n#define PIN_LCD_STROBE      2 // CD4094 8-bit shift/latch\n#define PIN_LCD_DATA        3 // CD4094 8-bit shift/latch\n#define PIN_LCD_CLOCK       4 // CD4094 8-bit shift/latch\n#define PIN_LIGHT_SENSOR 0\n\nvoid setup() {\n  Events.addHandler(ldrHandler, 1000);\n  Events.addHandler(lcdHandler,   1000);\n}\n\nvoid loop() {\n  Events.loop();\n}\n\nint ldr = 0;\n\nvoid ldrHandler(void) {\n ldr = analogRead(PIN_LIGHT_SENSOR);\n\n}\n\n/* -------------------------------------------------------------------------- */\n/* LCD KS0066 4-bit data interface, 3 Arduino pins and MC14094 8-bit register\n * http://www.datasheetsite.com/datasheet/KS0066\n *\n * MC14094 input:  Arduino digital pin 2=Clock, pin 4=Data, pin 7=Strobe\n * MC14094 output: Q8=DB4, Q7=DB5, Q6=DB6, Q5=DB7, Q4=E, Q3=RW, Q2=RS, Q1=None\n * http://www.ee.mut.ac.th/datasheet/MC14094.pdf\n *\n *   +--------------------------------------------+\n *   |    Arduino (ATMega 168 or 328)             |\n *   |    D02           D03           D04         |\n *   +----+-------------+-------------+-----------+\n *        |4            |5            |6\n *        |1            |2            |3\n *   +----+-------------+-------------+-----------+\n *   |    Strobe        Data          Clock       |\n *   |    MC14094 8-bit shift/latch register      |\n *   |    Q8   Q7   Q6   Q5   Q4   Q3   Q2   Q1   |\n *   +----+----+----+----+----+----+----+----+----+\n *        |11  |12  |13  |14  |7   |6   |5   |4\n *        |11  |12  |13  |14  |6   |5   |4 \n *   +----+----+----+----+----+----+----+---------+\n *   |    DB4  DB5  DB6  DB7  E    RW   RS        |\n *   |               LCD KS0066                   |\n *   +--------------------------------------------+\n */\n\nbyte lcdInitialized = false;\n\n// LCD pin bit-patterns, output from MC14094 -> LCD KS0066 input\n#define LCD_ENABLE_HIGH 0x10  // MC14094 Q4 -> LCD E\n#define LCD_ENABLE_LOW  0xEF  //   Enable (high) / Disable (low)\n#define LCD_RW_HIGH     0x20  // MC14094 Q3 -> LCD RW\n#define LCD_RW_LOW      0xDF  //   Read (high) / Write (low)\n#define LCD_RS_HIGH     0x40  // MC14094 Q2 -> LCD RS\n#define LCD_RS_LOW      0xBF  //   Data (high) / Instruction (low) Select\n\n// LCD Commands\n#define LCD_COMMAND_CLEAR             0x01  // Clear display\n#define LCD_COMMAND_HOME              0x02  // Set DD RAM address counter to (0, 0)\n#define LCD_COMMAND_ENTRY_SET         0x06  // Entry mode set\n#define LCD_COMMAND_DISPLAY_SET       0x0C  // Display on/off control\n#define LCD_COMMAND_FUNCTION_SET      0x28  // Function set\n#define LCD_COMMAND_SET_DDRAM_ADDRESS 0x80  // Set DD RAM address counter (row, column)\n\n#define LCD_SECOND_ROW 0x40  // Second row literal\n\nbyte lcdSetup[] = {         // LCD command, delay time in milliseconds\n  LCD_COMMAND_HOME,         50,  // wait for LCD controller to be initialized\n  LCD_COMMAND_HOME,         50,  // ditto\n  LCD_COMMAND_FUNCTION_SET,  1,  // 4-bit interface, 2 display lines, 5x8 font\n  LCD_COMMAND_DISPLAY_SET,   1,  // turn display on, cursor off, blinking off\n  LCD_COMMAND_CLEAR,         2,  // clear display\n  LCD_COMMAND_ENTRY_SET,     1   // increment mode, display shift off\n};\n\nvoid lcdInitialize(void) {\n  pinMode(PIN_LCD_CLOCK,  OUTPUT);\n  pinMode(PIN_LCD_DATA,   OUTPUT);\n  pinMode(PIN_LCD_STROBE, OUTPUT);\n\n  byte length = sizeof(lcdSetup) / sizeof(*lcdSetup);\n  byte index = 0;\n\n  while (index < length) {\n    lcdWrite(lcdSetup[index ++], false);\n    delay(lcdSetup[index ++]);\n  }\n\n  lcdInitialized = true;\n}\n\nvoid lcdWrite(\n  byte value,\n  byte dataFlag) {\n\n  digitalWrite(PIN_LCD_STROBE, LOW);\n\n  byte output = value >> 4;                                    // Most Significant Nibble\n  if (dataFlag) output = (output | LCD_RS_HIGH) & LCD_RW_LOW;  // Command or Data ?\n\n  for (byte loop1 = 0; loop1 < 2; loop1 ++) {  // First MSN, then LSN\n    for (byte loop2 = 0; loop2 < 3; loop2 ++) {  // LCD ENABLE LOW -> HIGH -> LOW\n      output = (loop2 == 1) ? (output | LCD_ENABLE_HIGH) : (output & LCD_ENABLE_LOW);\n\n      shiftOut(PIN_LCD_DATA, PIN_LCD_CLOCK, LSBFIRST, output);\n      digitalWrite(PIN_LCD_STROBE, HIGH);\n      delayMicroseconds(10);\n      digitalWrite(PIN_LCD_STROBE,LOW);\n    }\ndelay(1);\n    output = value & 0x0F;                                       // Least Significant Nibble\n    if (dataFlag) output = (output | LCD_RS_HIGH) & LCD_RW_LOW;  // Command or Data ?\n  }\n}\n\nvoid lcdClear(void) {\n  lcdWrite(LCD_COMMAND_CLEAR, false);\n  delay(2);\n}\n\nvoid lcdPosition(\n  byte row,        // Must be either 0 (first row) or 1 (second row)\n  byte column) {   // Must be between 0 and 15\n\n  if (row == 1) row = LCD_SECOND_ROW;\n  lcdWrite(LCD_COMMAND_SET_DDRAM_ADDRESS | row | column, false);\n  delayMicroseconds(40);\n}\n\nvoid lcdWriteString(\n  char message[]) {\n\n  while (*message) lcdWrite((*message ++), true);\n}\n\n// checks out how many digits there are in a number\n\nint estimateDigits(int nr) {\n  int dec = 10;\n  int temp = 1;\n  int div = nr/dec;\n  while (div > 0) {\n    dec *= 10;\n    div = nr/dec;\n    temp++;\n  }\n  return temp;\n}\n\n// Raise number to power\n\nint pow(int base, int expo) {\n  int temp = 1;\n  for (int c = 1; c <= expo; c++) {\n    temp *= base;\n  }\n  return temp;\n}\n\n// this function help us to write numbers\n// with more than one digit\n\nvoid lcdWriteNumber(int nr, int digits) {\n  for (int i = digits-1; i >= 0; i--) {\n    int dec = pow(10,i);\n    int div = nr/dec;\n    lcdWrite(div+48, true);\n    if (div > 0) {\n      nr -= div*dec;\n    }\n  }\n}\n\nvoid lcdWriteNumber(int nr) {\n  int value = nr;\n\n  if (value < 0) {\n    lcdWrite('-', true);\n    value = - nr;\n  }\n\n  int digits = estimateDigits(value);\n  lcdWriteNumber(value, digits);\n}\n\nvoid lcdHandler(void) {\n  if (lcdInitialized == false) {\n    lcdInitialize();\n    lcdClear();\n  }\n\n  lcdPosition(0, 8);\n  lcdWriteNumber((int) ldr);\n\n}\n</pre>\n\n===3 buttons===\n\n====Description====\nThese buttons are in a 'ladder' configuration meaning they only actually use 1 pin, A2, to implement all 3 buttons! Very generally speaking when one button is pressed something like 4/5 of voltage is read across the pin, when a different button is pressed 3/5 of voltage is read across pin, when third 2/5 of voltage is read, if 2 buttons are pressed then some combination of the 2 voltages is read!  This means you can not only test for 1 of the 3 buttons to be pressed, but you could check to see if 2 or 3 or all 3 buttons were pressed even though they're connected to one pin!\n\n====Code====\nThis code is very basic and simply adapts the Arduino analog input, analog output, serial output example and changes the Analog input pin to match our pin, A2.\n<pre>\n/*\n  Analog input, analog output, serial output\n \n Reads an analog input pin, maps the result to a range from 0 to 255\n and uses the result to set the pulsewidth modulation (PWM) of an output pin.\n Also prints the results to the serial monitor.\n \n The circuit:\n * potentiometer connected to analog pin 0.\n   Center pin of the potentiometer goes to the analog pin.\n   side pins of the potentiometer go to +5V and ground\n * LED connected from digital pin 9 to ground\n \n created 29 Dec. 2008\n Modified 4 Sep 2010\n by Tom Igoe\n \n This example code is in the public domain.\n \n */\n\n// These constants won't change.  They're used to give names\n// to the pins used:\nconst int analogInPin = A2;  // Analog input pin that the potentiometer is attached to\nconst int analogOutPin = 9; // Analog output pin that the LED is attached to\n\nint sensorValue = 0;        // value read from the pot\nint outputValue = 0;        // value output to the PWM (analog out)\n\nvoid setup() {\n  // initialize serial communications at 9600 bps:\n  Serial.begin(9600); \n}\n\nvoid loop() {\n  // read the analog in value:\n  sensorValue = analogRead(analogInPin);            \n  // map it to the range of the analog out:\n  outputValue = map(sensorValue, 0, 1023, 0, 255);  \n  // change the analog out value:\n  analogWrite(analogOutPin, outputValue);           \n\n  // print the results to the serial monitor:\n  Serial.print(\"sensor = \" );                       \n  Serial.print(sensorValue);      \n  Serial.print(\"\\t output = \");      \n  Serial.println(outputValue);   \n\n  // wait 10 milliseconds before the next loop\n  // for the analog-to-digital converter to settle\n  // after the last reading:\n  delay(10);                     \n}\n</pre>\n\n====Alternative code for Buttons====\nHere is a useful function you can use to check which buttons are being pressed. See the comments for more details. Don't feel bad if you can't follow the formulas...\n\n<pre>\nbyte getbuttons(void)\n{\n  // Sample code to read Pebble Shield buttons\n  // (C) 2011 Heatsync Labs (www.heatsynclabs.org)\n  // Author: Jac Goudsmit\n  // This example is in the public domain.\n  //\n  // The return value is a bit pattern that represents which buttons are\n  // currently being pressed:\n  // 1=left button pressed\n  // 2=middle button pressed\n  // 4=right button pressed\n\n  byte result = 0;\n  int v = analogRead(A2);\n\n  // When no button is pressed, the value should be near 1023.\n  // If any buttons are pressed, the input sees a voltage divider with\n  // 10k towards VCC and a parallel network of resistors to GND.\n  // If we represent the parallel resistor by x, the value v that will\n  // be read by the A/D converter will be close to the following:\n  // x=1/(1/(L*39k)+1/(M*22k)+1/(R*10k))    [law of parallel resistors]\n  // v=(x/(x+10k))*1024      [voltage divider between value 1023 and 0]\n  // This results in the following approximate values:\n  // L=0 M=0 R=0 ->       -> v=           =1023\n  // L=1 M=0 R=0 -> x=39k -> v=(39/49)*1024=815\n  // L=0 M=1 R=0 -> x=22k -> v=(22/32)*1024=704\n  // L=1 M=1 R=0 -> x=14k -> v=(14/24)*1024=597\n  // L=0 M=0 R=1 -> x=10k -> v=(10/20)*1024=512\n  // L=1 M=0 R=1 -> x=8k  -> v=(8/18) *1024=455\n  // L=0 M=1 R=1 -> x=7k  -> v=(7/17) *1024=417\n  // L=1 M=1 R=1 -> x=6k  -> v=(6/16) *1024=378\n  // Some variation is to be expected because of tolerances in the\n  // resistors and other real-world variations like temperature, so \n  // instead of checking for these exact values, we should check\n  // for ranges of values.\n  // It's probably not too hard to come up with a really cool\n  // algorithm that does successive aproximation or something but\n  // because there only are 8 possible outcomes, looking the A/D\n  // converter value up in a table probably saves time and space.\n  // The table contains averages of each pair of values in\n  // the list above.\n  const static int cv[7] = \n  { \n    919, // (1023+815)/2\n    759, //  (815+704)/2\n    651, //  (704+597)/2\n    555, //  (597+512)/2\n    484, //  (512+455)/2\n    436, //  (455+417)/2\n    398  //  (417+378)/2\n  };\n  \n  for (int i = 0; i < 7; i++)\n  {\n    if (v <= cv[i])\n    {\n      result++;\n    }\n    else\n    {\n      break;\n    }\n  }  \n  \n  return result;\n}\n</pre>\n\n===Potentiometer===\n\n====Description====\nA potentiometer is simply a resistor that we can manually vary the resistance of.  Potentiometers are everywhere.  The knob on your stereo is a potentiometer that controls the volume!  Our potentiometer is connected internally to A1 of the Arduino. It's connected as a voltage divider, so turning the pot adjusts the voltage on the analog input between 0 and 5 Volts.\n\n====Code====\nThe following code simply adapts the Arduino analog input, analog output, serial output example to use the appropriate analog pin, A1.\n\n<pre>\n/*\n  Analog input, analog output, serial output\n \n Reads an analog input pin, maps the result to a range from 0 to 255\n and uses the result to set the pulsewidth modulation (PWM) of an output pin.\n Also prints the results to the serial monitor.\n \n The circuit:\n * potentiometer connected to analog pin 0.\n   Center pin of the potentiometer goes to the analog pin.\n   side pins of the potentiometer go to +5V and ground\n * LED connected from digital pin 9 to ground\n \n created 29 Dec. 2008\n Modified 4 Sep 2010\n by Tom Igoe\n \n This example code is in the public domain.\n \n */\n\n// These constants won't change.  They're used to give names\n// to the pins used:\nconst int analogInPin = A1;  // Analog input pin that the potentiometer is attached to\nconst int analogOutPin = 9; // Analog output pin that the LED is attached to\n\nint sensorValue = 0;        // value read from the pot\nint outputValue = 0;        // value output to the PWM (analog out)\n\nvoid setup() {\n  // initialize serial communications at 9600 bps:\n  Serial.begin(9600); \n}\n\nvoid loop() {\n  // read the analog in value:\n  sensorValue = analogRead(analogInPin);            \n  // map it to the range of the analog out:\n  outputValue = map(sensorValue, 0, 1023, 0, 255);  \n  // change the analog out value:\n  analogWrite(analogOutPin, outputValue);           \n\n  // print the results to the serial monitor:\n  Serial.print(\"sensor = \" );                       \n  Serial.print(sensorValue);      \n  Serial.print(\"\\t output = \");      \n  Serial.println(outputValue);   \n\n  // wait 10 milliseconds before the next loop\n  // for the analog-to-digital converter to settle\n  // after the last reading:\n  delay(10);                     \n}\n</pre>\n\n===Relays===\n\n====Description====\n\nTwo reed relays are provided on the board.  Relays are used to switch more power hungry things on and off.  Small LEDs can simply be connected up to the arduino pins directly, but rather large LEDS or motors might draw too much current and need to be switched through a relay.  These relays are exposed on the 6 pin right angle header in the upper left.  The pin closest to the edge of the board is pin 1, and the furthest in is considered pin 6. These relays are small \"reed relays\", which are cool because their coils will only draw about 10 mA at 5 V when switched on, meaning that they can be switched on and off directly from the Arduino, without the use of a transistor. However, these relays can switch a maximum load current of only about 1 amp.\n\n*Pin1 - Gnd\n*Pin2 - Relay 1 Side 1\n*Pin3 - Relay 1 Side 2\n*Pin4 - Relay 2 Side 1\n*Pin5 - Relay 2 Side 2\n*Pin6  - 5V\n\nWhat you need to understand about these relays is that they are NOT connected to voltage internally by the board.  You need to INPUT power(Pin6) to one of the sides of the relay (Pin5), then connect the other side of the relay(Pin4) to your load (a resistor, motor, etc) and then the other side of that load to GND. \n XXX Picture here\n\nXXX add datasheet and relay image here.\n\n====Code====\nThe relay code is unchanged and should be found under the pebble examples.\n\n====Testing and Debugging====\nWhen a relay switches it generally makes a little click sound so you should be able to hear that if your relay is working properly.\n\n==Optional Features==\n\n===LCD===\n\n====Description====\n\nThe lcd screen, when plugged in correctly, should hang over and 'block' access to the electronics and board underneath.  Also note the potentiometer.  The pot controls the contrast of the characters on screen and should generally be set nearly all the way clockwise.\nThe LCD we use is purchased from [http://www.adafruit.com/index.php?main_page=product_info&cPath=37&products_id=181 Adafruit], or you can stop contact us.\n\nPlease see pictures below:\nXXX Insert Picture of pot turned right, XXX insert picture of lcd correct placement\n\n====Code====\nThe LCD code remains unchanged from the pebble display example.\n\n===Xbee===\n\n====Description====\n\nThe Xbee module allows communication with other devices through the Zigbee protocol which is somewhat similar to Bluetooth.\n\n====Code====\nWe currently have no code to show off this device.",
    "bytes": 27026
  },
  "revision_count": 12,
  "first_revision_timestamp": "2011-01-14T15:31:32Z",
  "is_redirect": false
}